# リトライ時のメッセージフィルタリングとトークン削減

## 目次

1. [概要](#概要)
2. [なぜメッセージを除外するのか](#なぜメッセージを除外するのか)
3. [除外対象のメッセージ](#除外対象のメッセージ)
4. [実装コード](#実装コード)
5. [具体例：リトライの流れ](#具体例リトライの流れ)
6. [問題点と改善案](#問題点と改善案)
7. [まとめ](#まとめ)

---

## 概要

### 問題

サブタスク実行中にリトライが発生すると、**過去のメッセージ履歴をすべてOpenAI APIに送信**することになります。

特に**検索結果（3000〜5000トークン）**を含むと、トークン数が爆発的に増加し、**コストが膨大**になります。

### 解決策

agent.pyでは、リトライ時に以下を除外してトークン数を削減しています：

- ✂️ **検索結果（長文）**：`role: "tool"` のメッセージ
- ✂️ **ツール呼び出し**：`tool_calls` を含むメッセージ

**削減効果**：約90%のトークン削減（リトライ時）

---

## なぜメッセージを除外するのか

### トークン数の増加例

```python
messages = [
    {"role": "system", "content": "..."},  # 100トークン
    {"role": "user", "content": "サブタスク: ERR-404を調査"},  # 50トークン
    {"role": "assistant", "tool_calls": [...]},  # 50トークン
    {"role": "tool", "content": "【3000文字の検索結果】..."},  # 4000トークン ⬅ 長い！
    {"role": "assistant", "content": "ERR-404は..."},  # 30トークン
    {"role": "assistant", "content": "評価: NG..."},  # 50トークン
]

# 合計: 約4280トークン
```

**リトライのたびにこれを送信すると**：
- 1回目: 4280トークン
- 2回目: 8560トークン
- 3回目: 12840トークン

### コストの増加

| 試行回数 | 累積トークン | コスト（GPT-4o） |
|---------|------------|---------------|
| 初回 | 4,280 | $0.011 |
| リトライ1回 | 8,560 | $0.021 |
| リトライ2回 | 12,840 | $0.032 |
| リトライ3回 | 17,120 | $0.043 |

**年間のコスト例**（100ユーザー、1日3質問、3サブタスク、1リトライ）：
- フィルタリングなし: 約**110万円/年**
- フィルタリングあり: 約**40万円/年**
- **削減額: 70万円/年**

### リトライ時に必要な情報

| 情報 | 必要性 | 理由 |
|-----|-------|------|
| 前回の回答 | ✅ 必要 | どんな回答を生成したか |
| 内省結果 | ✅ 必要 | なぜNGだったか |
| サブタスク | ✅ 必要 | 何を調査すべきか |
| 検索結果の詳細 | ❌ 不要 | 新しく検索するため |
| ツール呼び出し詳細 | ❌ 不要 | 新しく選択するため |

AIは「前回の結果が不十分だった」というコンテキストを理解し、新しく検索するため、**前回の検索結果の詳細（長文）は不要**です。

---

## 除外対象のメッセージ

### 1. `role: "tool"` のメッセージ（検索結果）

```python
{
    "role": "tool",
    "tool_call_id": "call_abc123",
    "content": "【検索結果】\n\nファイル: ...\n内容: ..."  # ⬅ 3000〜5000トークン
}
```

**除外理由**：
- 最も長い（3000〜5000トークン）
- リトライ時は新しく検索するため不要

### 2. `tool_calls` を含むメッセージ（ツール呼び出し）

```python
{
    "role": "assistant",
    "content": None,
    "tool_calls": [
        {
            "id": "call_abc123",
            "function": {
                "name": "search_xyz_manual",  # ⬅ どのツールを使ったか
                "arguments": '{"keywords": "ERR-404"}'
            }
        }
    ]
}
```

**除外理由**：
- リトライ時は新しくツールを選択するため不要
- 200〜500トークンの削減効果

---

## 実装コード

### agent.pyでの実装

```python
def select_tools(self, state: AgentSubGraphState) -> dict:
    """サブタスクに最適なツールを選択する"""
    
    if state["challenge_count"] == 0:
        # === 初回の場合 ===
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_FOR_TOOL_SELECTION},
            {"role": "user", "content": f"サブタスク: {state['subtask']}"},
        ]
    else:
        # === リトライの場合 ===
        messages = state["messages"]
        
        # NOTE: トークン数節約のため、過去の検索結果（長文）は除外
        # roleが"tool"のメッセージ（検索結果）と
        # "tool_calls"を含むメッセージ（ツール呼び出し）を除外
        filtered_messages = []
        for message in messages:
            if message["role"] == "tool" or "tool_calls" in message:
                continue
            filtered_messages.append(message)
        messages = filtered_messages
        
        # リトライを促すプロンプトを追加
        messages.append({
            "role": "user",
            "content": "前回の結果が不十分でした。別のツールや別のキーワードで再試行してください。"
        })
    
    # OpenAI APIを呼び出し
    # ...
```

### フィルタリング関数（推奨実装）

```python
def filter_messages_for_retry(messages: list) -> list:
    """
    リトライ時のメッセージをフィルタリング
    
    除外:
    - role が "tool" のメッセージ（検索結果）
    - tool_calls を含むメッセージ（ツール呼び出し）
    """
    filtered = []
    for message in messages:
        # 検索結果を除外
        if message.get("role") == "tool":
            continue
        # ツール呼び出しを除外
        if "tool_calls" in message:
            continue
        filtered.append(message)
    return filtered
```

---

## 具体例：リトライの流れ

### ステップ1: 初回実行

```python
messages = [
    {"role": "system", "content": "システムプロンプト"},
    {"role": "user", "content": "ERR-404を調査"},
    {"role": "assistant", "tool_calls": [{"function": {"name": "search_xyz_manual"}}]},
    {"role": "tool", "content": "【3000文字の検索結果】"},
    {"role": "assistant", "content": "ERR-404はリソースが見つからないエラーです。"},
    {"role": "assistant", "content": "評価: NG。対処法が不足しています。"},
]
# 合計: 約4300トークン
```

### ステップ2: リトライ（フィルタリングあり）

```python
# フィルタリング後
messages = [
    {"role": "system", "content": "システムプロンプト"},
    {"role": "user", "content": "ERR-404を調査"},
    # ← tool_calls を除外
    # ← 検索結果を除外
    {"role": "assistant", "content": "ERR-404はリソースが見つからないエラーです。"},
    {"role": "assistant", "content": "評価: NG。対処法が不足しています。"},
    {"role": "user", "content": "前回の結果が不十分でした。別のツールで再試行してください。"},
]
# 合計: 約250トークン
```

**削減効果**: 4300トークン → 250トークン（**約94%削減**）

---

## 問題点と改善案

### 🚨 問題点：前に使用したツールがわからない

`tool_calls`を除外すると、**どのツールを使ったか**の情報も消えます。

```python
# 除外されるメッセージ
{
    "role": "assistant",
    "tool_calls": [{
        "function": {
            "name": "search_xyz_manual",  # ⬅ この情報が消える！
            "arguments": '{"keywords": "ERR-404"}'
        }
    }]
}

# AIへの指示
"前回の結果が不十分でした。別のツールや別のキーワードで再試行してください。"
# ⬆ でも「前回のツール」がわからない！
```

**影響**：
- AIが同じツールを再選択する可能性がある
- 「別のツール」と指示しても、どれが「別」なのか不明

### ✅ 改善案1：ツール名だけ残す

```python
def filter_messages_with_tool_names(messages: list) -> list:
    """ツール名だけ残してフィルタリング"""
    filtered = []
    for message in messages:
        # 検索結果は除外
        if message.get("role") == "tool":
            continue
        
        # ツール呼び出しは関数名だけ残す
        if "tool_calls" in message:
            tool_names = [
                tc["function"]["name"] 
                for tc in message.get("tool_calls", [])
            ]
            # 簡潔なメッセージに変換
            filtered.append({
                "role": "assistant",
                "content": f"使用したツール: {', '.join(tool_names)}"
            })
            continue
        
        filtered.append(message)
    return filtered
```

**効果**：
- トークン数を大幅削減（検索結果を除外）
- 使用したツール名は保持
- AIが「別のツール」を正しく選択できる

### ✅ 改善案2：内省結果に含める

```python
# 内省時に使用したツールを記録
{
    "role": "assistant",
    "content": "評価: NG。search_xyz_manualで検索しましたが、対処法が不足しています。別のツール（search_xyz_qa）で再試行してください。"
}
```

**利点**：
- `tool_calls`を除外しても、内省結果にツール名が残る
- AIに明確な指示ができる

### ✅ 改善案3：リトライ指示を具体化

現在のコード（agent.py）では、内省結果（`ReflectionResult`）にツール情報が含まれている可能性があります。

```python
class ReflectionResult(BaseModel):
    """内省結果"""
    is_completed: bool = Field(description="完了したかどうか")
    reflection: str = Field(description="内省の内容")  # ⬅ ここにツール情報が含まれる
```

したがって、実際には内省結果を通じて「前回のツール」の情報が伝わっている可能性があります。

---

## まとめ

### フィルタリングの効果

| 項目 | 効果 |
|-----|------|
| トークン削減 | 約90%削減（リトライ時） |
| コスト削減 | 約70%削減（年間70万円の例） |
| 実行速度 | 送信データ量減少で高速化 |

### 除外対象

1. **`role: "tool"`**（検索結果）→ 3000〜5000トークン削減
2. **`tool_calls`**（ツール呼び出し）→ 200〜500トークン削減

### 実装のポイント

```python
# シンプルなフィルタリング
filtered = [
    msg for msg in messages 
    if msg.get("role") != "tool" and "tool_calls" not in msg
]
```

### 問題点と対策

**問題**：`tool_calls`を除外すると、前に使用したツール名がわからない

**対策**：
1. ツール名だけ残す（簡潔なメッセージに変換）
2. 内省結果にツール情報を含める
3. 実際には内省結果（`reflection`）にツール名が含まれている可能性が高い

### ベストプラクティス

- ✅ 検索結果（長文）は必ず除外
- ✅ ツール呼び出しは、ツール名だけ残して除外
- ✅ トークン数を監視（ログ出力）
- ✅ 内省結果にツール情報を含める
- ✅ テストで効果を検証

このフィルタリング処理により、**大幅なコスト削減を実現しながら、エージェントの性能を維持**しています。

