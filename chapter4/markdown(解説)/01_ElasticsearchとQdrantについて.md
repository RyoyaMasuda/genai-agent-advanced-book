# ElasticsearchとQdrantの比較と解説

## 目次

1. [Elasticsearchとは](#elasticsearchとは)
2. [Qdrantとは](#qdrantとは)
3. [主な違い](#主な違い)
4. [このプロジェクトでの使い分け](#このプロジェクトでの使い分け)
5. [検索方式の比較](#検索方式の比較)
6. [実装例](#実装例)

---

## Elasticsearchとは

### 概要

**Elasticsearch**は、Apache Luceneをベースにした**全文検索エンジン**およびデータ分析エンジンです。分散型のRESTful検索・分析エンジンとして、大量のデータを高速に検索・分析できます。

### 主な特徴

#### 1. 全文検索（Full-Text Search）
- **キーワードマッチング**に特化
- テキスト内の単語や文字列を検索
- 形態素解析やトークン化により、日本語などの複雑な言語も対応
- 類義語辞書やステミング（語幹抽出）をサポート

#### 2. インデックスベースの高速検索
- 転置インデックス（Inverted Index）を使用
- 文書内の単語から文書を逆引きできる構造
- 大量のデータでも高速な検索が可能

#### 3. RESTful API
- HTTP経由でのシンプルなAPI
- JSONフォーマットでのデータのやり取り
- cURLやHTTPクライアントで簡単にアクセス可能

#### 4. 分散アーキテクチャ
- 複数のノードでデータを分散管理
- 水平スケーリングが容易
- 高可用性とフォールトトレランス

#### 5. 豊富な検索クエリ
- **Match Query**: 全文検索
- **Term Query**: 完全一致検索
- **Range Query**: 範囲検索
- **Bool Query**: 複数条件の組み合わせ
- **Fuzzy Query**: あいまい検索

### 使用例

```json
// キーワード検索のクエリ例
{
  "query": {
    "match": {
      "content": "エラーコード 404"
    }
  }
}
```

### 適している用途

- **キーワードベースの検索**
- ログ分析（ELKスタック: Elasticsearch + Logstash + Kibana）
- Webサイトの全文検索
- エラーコードや固有名詞の検索
- 時系列データの分析
- ビジネスインテリジェンス

---

## Qdrantとは

### 概要

**Qdrant**（クアドラント）は、**ベクトル検索**（Vector Search）に特化した**ベクトルデータベース**です。機械学習モデルが生成した埋め込みベクトル（Embedding）を格納し、類似度検索を高速に実行できます。

### 主な特徴

#### 1. ベクトル検索（Vector Search）
- **意味的類似性**に基づく検索
- テキストの埋め込みベクトル（数値の配列）を使用
- 言い換えや類義語も自動的に検出可能
- キーワードが一致しなくても意味が近ければヒット

#### 2. 高速な近似最近傍探索（ANN）
- HNSW（Hierarchical Navigable Small World）アルゴリズムを使用
- 大規模なベクトルデータでも高速検索
- リアルタイムの類似度検索に対応

#### 3. 柔軟なフィルタリング
- ベクトル検索とメタデータフィルタリングの組み合わせ
- ペイロードを使った追加情報の管理
- 条件付き検索が可能

#### 4. REST APIとgRPC
- HTTP REST APIでのアクセス
- 高速なgRPCもサポート
- Pythonクライアントライブラリが充実

#### 5. スケーラビリティ
- 水平スケーリングに対応
- クラスタリング機能
- 数百万〜数億のベクトルを扱える

### 使用例

```python
# ベクトル検索のクエリ例
query_vector = [0.1, 0.2, 0.3, ...]  # 768次元のベクトル

qdrant_client.query_points(
    collection_name="documents",
    query=query_vector,
    limit=3
)
```

### 適している用途

- **意味的類似性検索**
- セマンティック検索
- 質問応答システム（QAシステム）
- レコメンデーションシステム
- 画像・音声の類似検索
- RAG（Retrieval-Augmented Generation）システム
- チャットボットの知識ベース

---

## 主な違い

| 項目 | Elasticsearch | Qdrant |
|------|--------------|--------|
| **検索タイプ** | キーワード検索（全文検索） | ベクトル検索（意味検索） |
| **検索方式** | 単語のマッチング | 意味的類似性 |
| **データ構造** | テキスト、JSON | ベクトル（数値配列） |
| **インデックス** | 転置インデックス | HNSW（グラフベース） |
| **検索精度** | キーワードが一致すれば高精度 | 意味が似ていれば検出 |
| **言い換え対応** | 辞書が必要 | 自動的に対応 |
| **処理コスト** | 比較的低い | Embedding生成が必要（高い） |
| **エラーコード検索** | 得意 | 不得意 |
| **自然言語質問** | やや不得意 | 得意 |

---

## このプロジェクトでの使い分け

### search_xyz_manual.py（Elasticsearch使用）

**目的**: XYZシステムのマニュアルやドキュメントから**特定のキーワード**を検索

**使用ケース**:
- エラーコードの検索（例: "ERR-404"）
- 固有名詞の検索（例: "ログイン機能"）
- 正確な用語の検索（例: "データベース接続"）
- 技術用語の検索

**検索フロー**:
```
ユーザークエリ
  ↓
キーワード抽出
  ↓
Elasticsearch検索（match query）
  ↓
関連ドキュメント取得
```

**具体例**:
```python
# クエリ: "ERR-404 エラー"
# → "ERR-404"というキーワードを含む文書を検索
search_xyz_manual(keywords="ERR-404")
```

### search_xyz_qa.py（Qdrant使用）

**目的**: 過去の質問回答ペアから**意味的に類似した質問**を検索

**使用ケース**:
- 自然言語の質問検索
- 言い換えた質問の検索（例: "ログインできない" ≈ "サインインに失敗する"）
- 類似のトラブル検索
- 過去の質問履歴からの回答検索

**検索フロー**:
```
ユーザークエリ
  ↓
OpenAI Embedding API（text-embedding-3-small）
  ↓
クエリベクトル生成（768次元）
  ↓
Qdrant検索（コサイン類似度）
  ↓
類似質問回答ペア取得
```

**具体例**:
```python
# クエリ: "パスワードを忘れた場合の対処法は？"
# → 過去に「パスワードリセット」「認証情報の再設定」などの
#   類似質問があれば、キーワードが違っても検出できる
search_xyz_qa(query="パスワードを忘れた場合の対処法は？")
```

---

## 検索方式の比較

### キーワード検索（Elasticsearch）の仕組み

#### 1. インデックス作成時

```
文書: "XYZシステムでERR-404エラーが発生しました"
      ↓ トークン化
単語: ["XYZ", "システム", "ERR-404", "エラー", "発生"]
      ↓ 転置インデックス作成
インデックス:
  "XYZ" → [文書1, 文書5, ...]
  "ERR-404" → [文書1, 文書10, ...]
  "エラー" → [文書1, 文書2, ...]
```

#### 2. 検索時

```
クエリ: "ERR-404"
  ↓ インデックスを参照
文書1, 文書10がヒット
  ↓ スコアリング（TF-IDF等）
関連度の高い順に結果を返す
```

#### メリット
- ✅ 特定のキーワードを確実に検索
- ✅ 高速（インデックスの参照のみ）
- ✅ エラーコードや固有名詞に強い

#### デメリット
- ❌ キーワードが一致しないと検出できない
- ❌ 言い換えに弱い（"ログイン" ≠ "サインイン"）
- ❌ 意味的な理解はできない

---

### ベクトル検索（Qdrant）の仕組み

#### 1. インデックス作成時

```
文書: "XYZシステムにログインできません"
      ↓ Embedding API
ベクトル: [0.12, -0.34, 0.56, ..., 0.78]  ※768次元
      ↓ Qdrantに格納
ベクトルデータベースに保存
```

#### 2. 検索時

```
クエリ: "サインインに失敗します"
  ↓ Embedding API
クエリベクトル: [0.15, -0.32, 0.54, ..., 0.80]
  ↓ 類似度計算（コサイン類似度）
類似ベクトルを検索
  ↓ 近似最近傍探索（ANN）
意味的に近い文書を返す
```

**数学的な類似度計算**:
```
コサイン類似度 = (ベクトルA・ベクトルB) / (|A| × |B|)

値が1に近いほど類似、0に近いほど非類似
```

#### メリット
- ✅ 意味的な類似性を検出
- ✅ 言い換えに強い（"ログイン" ≈ "サインイン"）
- ✅ 自然言語の質問に対応
- ✅ キーワードが一致しなくても検索可能

#### デメリット
- ❌ Embedding生成にコストがかかる（API呼び出し）
- ❌ エラーコードなど固有の文字列には弱い
- ❌ 計算コストが高い（ベクトル演算）

---

## 実装例

### Elasticsearchの実装（search_xyz_manual.py）

```python
from elasticsearch import Elasticsearch

# Elasticsearchクライアントの初期化
es = Elasticsearch("http://localhost:9200")

# キーワード検索クエリ
keyword_query = {
    "query": {
        "match": {
            "content": "ERR-404"  # キーワード
        }
    }
}

# 検索実行
response = es.search(index="documents", body=keyword_query)

# 結果の取得
for hit in response["hits"]["hits"]:
    print(f"Score: {hit['_score']}")
    print(f"Content: {hit['_source']['content']}")
```

**検索の流れ**:
1. キーワードを指定
2. Elasticsearchが転置インデックスを参照
3. マッチした文書を返す

---

### Qdrantの実装（search_xyz_qa.py）

```python
from qdrant_client import QdrantClient
from openai import OpenAI

# Qdrantクライアントの初期化
qdrant_client = QdrantClient("http://localhost:6333")

# OpenAIクライアントの初期化
openai_client = OpenAI(api_key="your-api-key")

# ステップ1: クエリをベクトルに変換
query = "ログインできない場合はどうすればいいですか？"
query_vector = (
    openai_client.embeddings.create(
        input=query,
        model="text-embedding-3-small"
    )
    .data[0]
    .embedding
)  # 768次元のベクトルを取得

# ステップ2: ベクトル検索
search_results = qdrant_client.query_points(
    collection_name="documents",
    query=query_vector,  # クエリのベクトル
    limit=3  # 上位3件
)

# 結果の取得
for point in search_results.points:
    print(f"Score: {point.score}")  # 類似度スコア
    print(f"Content: {point.payload['content']}")
```

**検索の流れ**:
1. クエリをEmbedding APIでベクトル化（768次元）
2. Qdrantが既存のベクトルと類似度を計算
3. 最も類似度が高いベクトル（文書）を返す

---

## ベクトル（Embedding）とは

### Embeddingの概念

**Embedding（埋め込み）**とは、テキストを数値のベクトル（数値の配列）に変換したものです。

#### 例

```python
# テキスト
text = "こんにちは"

# Embedding（簡略化した例、実際は768次元）
vector = [0.1, -0.3, 0.5, 0.2, -0.1, ...]

# 類似したテキストは近いベクトルになる
text1 = "こんにちは"      → [0.1, -0.3, 0.5, ...]
text2 = "こんにちわ"      → [0.1, -0.3, 0.5, ...]  ※近い
text3 = "Good morning"   → [0.8, 0.6, -0.2, ...]  ※遠い
text4 = "おはよう"        → [0.7, 0.4, -0.1, ...]  ※やや近い
```

### Embeddingの利点

1. **意味の数値化**: テキストの意味を数学的に表現
2. **類似度計算**: ベクトル間の距離で類似度を測定
3. **多次元空間での表現**: 複雑な意味関係を表現可能
4. **機械学習モデルとの相性**: ディープラーニングで学習したベクトル

---

## ハイブリッド検索の重要性

### なぜ両方を使うのか？

このプロジェクトでは、**ElasticsearchとQdrantの両方**を使用しています。これは、それぞれの強みを活かすためです。

#### シナリオ1: エラーコード検索

**ユーザーの質問**: "ERR-404というエラーが出ました"

- **Elasticsearch**: "ERR-404"というキーワードで検索 → ✅ 最適
- **Qdrant**: ベクトル検索では固有の文字列を正確に捉えにくい → ❌ 不向き

#### シナリオ2: 自然言語の質問

**ユーザーの質問**: "アカウントにアクセスできないのですが"

- **Elasticsearch**: "アクセスできない"というキーワードでしか検索できない → △ 限定的
- **Qdrant**: 「ログインできない」「認証に失敗」などの類似質問も検出 → ✅ 最適

### ベストプラクティス

```python
# エージェントが自動的に適切なツールを選択
if "ERR-" in user_query or "エラーコード" in user_query:
    # エラーコードが含まれる場合は Elasticsearch
    results = search_xyz_manual(keywords=extract_keywords(user_query))
else:
    # 自然言語の質問は Qdrant
    results = search_xyz_qa(query=user_query)
```

---

## まとめ

| 検索エンジン | 検索タイプ | 得意分野 | 苦手分野 |
|------------|----------|---------|---------|
| **Elasticsearch** | キーワード検索 | エラーコード、固有名詞、正確な用語 | 言い換え、意味的類似性 |
| **Qdrant** | ベクトル検索 | 自然言語、意味的類似性、言い換え | 固有の文字列、エラーコード |

### 使い分けのポイント

- **正確なキーワードが重要** → Elasticsearch
- **意味的な理解が必要** → Qdrant
- **最良の結果** → 両方を組み合わせたハイブリッド検索

このプロジェクトでは、LangChainのエージェントが状況に応じて自動的に適切なツールを選択し、最適な検索結果を提供します。

